<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Super Football Game</title>
<style>
  /* Reset & basic */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0;
    height: 100%;
    background: linear-gradient(180deg, #0a3d0a 0%, #1a7d1a 100%);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    user-select: none;
  }
  #container {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
  }
  canvas {
    display: block;
    background: #144214;
    border-radius: 12px;
    box-shadow: 0 0 24px rgba(0,0,0,0.8);
    max-width: 600px;
    max-height: 90vh;
    width: 100%;
    height: auto;
  }
  #info {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.6);
    color: #f0f0f0;
    font-weight: 700;
    font-size: 20px;
    padding: 10px 20px;
    border-radius: 30px;
    text-shadow: 0 0 6px #000;
    z-index: 10;
    pointer-events: none;
    min-width: 280px;
    text-align: center;
  }
  @media (max-width: 400px) {
    #info {
      font-size: 16px;
      min-width: 200px;
      padding: 8px 16px;
    }
  }
</style>
</head>
<body>
<div id="container">
  <canvas id="footballCanvas"></canvas>
  <div id="info"></div>
</div>

<script>
(() => {
  const canvas = document.getElementById('footballCanvas');
  const ctx = canvas.getContext('2d');
  const info = document.getElementById('info');

  // Responsive sizing function
  function resizeCanvas() {
    const w = Math.min(window.innerWidth, 600);
    const h = Math.min(window.innerHeight * 0.9, 700);
    canvas.width = w;
    canvas.height = h;
  }

  // Initial resize and bind resize event
  resizeCanvas();
  window.addEventListener('resize', () => {
    resizeCanvas();
    resetBall(); // Reset ball on resize for consistency
  });

  // Variables for canvas dimensions
  let W = canvas.width;
  let H = canvas.height;

  // Ball object
  let ball = { x: W / 2, y: H / 2, r: 18, vx: 0, vy: 0, moving: false };

  // Scores removed (per user request)

  // Random correct goal (either 'top' or 'bottom') and target center
  let correctGoal = Math.random() < 0.5 ? 'top' : 'bottom';
  // initialize targetCenter now; y will be set later in updateTargetCenter()
  let targetCenter = { x: W / 2, y: 0 };


  // Swipe tracking
  let swipeStart = null;
  let swipeEnd = null;
  let lastTouch = null;

  // Goal dimensions relative to canvas size
  const goalWidthRatio = 0.4;
  const goalHeight = 50;
  const friction = 0.97;

  // Keeper images placeholders (replace src with actual images if you have)
  const keeperLeft = new Image();
  keeperLeft.src = "bheem.png";

  const keeperRight = new Image();
  keeperRight.src = "bheem.png";

  // Keeper animation state, positions relative to canvas size and goals
  const keeper = {
    left: { x: 0, y: goalHeight + 10, width: 60, height: 90, dir: 1, speed: 1.5, offset: 0 },
    right: { x: 0, y: 0, width: 60, height: 90, dir: 1, speed: 1.5, offset: 0 }
  };

  // Update keeper positions on resize
  function updateKeepersPosition() {
    const goalWidth = W * goalWidthRatio;
    keeper.left.y = goalHeight + 10;
    keeper.left.offset = 0;
    keeper.left.x = W / 2 - goalWidth / 2 + 20;

    keeper.right.y = H - goalHeight - keeper.right.height - 10;
    keeper.right.offset = 0;
    keeper.right.x = W / 2 - goalWidth / 2 + 20;
    // update target center after keepers/size update
    updateTargetCenter();
  }

  updateKeepersPosition();

  // Draw the field
  function drawField() {
    const goalWidth = W * goalWidthRatio;

    // Background
    ctx.fillStyle = '#144214';
    ctx.fillRect(0, 0, W, H);

    // Center line
    ctx.strokeStyle = '#ffffffbb';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(W / 2, 0);
    ctx.lineTo(W / 2, H);
    ctx.stroke();

    // Center circle
    ctx.beginPath();
    ctx.arc(W / 2, H / 2, 60, 0, Math.PI * 2);
    ctx.stroke();

    // Goals - top and bottom
    ctx.fillStyle = '#ffffffcc';
    ctx.fillRect(W / 2 - goalWidth / 2, 0, goalWidth, goalHeight);
    ctx.fillRect(W / 2 - goalWidth / 2, H - goalHeight, goalWidth, goalHeight);

    // Goal frames
    ctx.strokeStyle = '#f2e394';
    ctx.lineWidth = 3;
    ctx.strokeRect(W / 2 - goalWidth / 2, 0, goalWidth, goalHeight);
    ctx.strokeRect(W / 2 - goalWidth / 2, H - goalHeight, goalWidth, goalHeight);

    // Draw goal labels. One goal is correct (Tokyo) and the other is wrong (New York).
    const goalCenterX = W / 2;
    const topLabel = (correctGoal === 'top') ? 'Tokyo' : 'New York';
    const bottomLabel = (correctGoal === 'bottom') ? 'Tokyo' : 'New York';
    ctx.save();
    ctx.fillStyle = '#111';
    ctx.font = 'bold 16px Segoe UI, Tahoma, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // top goal label
    ctx.fillText(topLabel, goalCenterX, goalHeight / 2);
    // bottom goal label
    ctx.fillText(bottomLabel, goalCenterX, H - goalHeight / 2);
    ctx.restore();
  }

  // Score display removed

  // Draw the ball with hexagon pattern
  function drawBall() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Hexagon pattern
    ctx.beginPath();
    const sides = 6;
    for (let i = 0; i < sides; i++) {
      const angle = (Math.PI * 2 / sides) * i - Math.PI / 2;
      const px = ball.x + Math.cos(angle) * ball.r * 0.6;
      const py = ball.y + Math.sin(angle) * ball.r * 0.6;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fillStyle = '#222';
    ctx.fill();
    // Draw outlined bright text for better visibility
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = 'bold 13px Segoe UI, Tahoma, sans-serif';
    // Add white outline for contrast
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.strokeText('japan capital', ball.x, ball.y);
    // Fill with bright color
    ctx.fillStyle = '#ffdd122';
    ctx.fillText('japan capital', ball.x, ball.y);
    ctx.restore();
  }

  // Move the ball with friction and bouncing
  function moveBall() {
    if (!ball.moving) return;

    ball.x += ball.vx;
    ball.y += ball.vy;
    ball.vx *= friction;
    ball.vy *= friction;

    // Stop ball if very slow
    if (Math.abs(ball.vx) < 0.15 && Math.abs(ball.vy) < 0.15) {
      ball.vx = 0;
      ball.vy = 0;
      ball.moving = false;
    }

    // Bounce off left and right walls
    if (ball.x - ball.r < 0) {
      ball.x = ball.r;
      ball.vx *= -0.7;
    }
    if (ball.x + ball.r > W) {
      ball.x = W - ball.r;
      ball.vx *= -0.7;
    }

    // Bounce on top/bottom outside goal area
    const goalWidth = W * goalWidthRatio;

    // Top boundary
    if (ball.y - ball.r < 0) {
      if (!(ball.x > W/2 - goalWidth/2 && ball.x < W/2 + goalWidth/2)) {
        ball.y = ball.r;
        ball.vy *= -0.7;
      }
    }
    // Bottom boundary
    if (ball.y + ball.r > H) {
      if (!(ball.x > W/2 - goalWidth/2 && ball.x < W/2 + goalWidth/2)) {
        ball.y = H - ball.r;
        ball.vy *= -0.7;
      }
    }
  }

  // Animate keepers inside goal frame
  function animateKeepers() {
    const goalWidth = W * goalWidthRatio;

    // Left keeper (top goal)
    const keeperTop = keeper.left;
    keeperTop.offset += keeperTop.dir * keeperTop.speed;
    if (keeperTop.offset > goalWidth - keeperTop.width - 40) keeperTop.dir = -1;
    else if (keeperTop.offset < 0) keeperTop.dir = 1;
    keeperTop.x = W / 2 - goalWidth / 2 + 20 + keeperTop.offset;

    // Right keeper (bottom goal)
    const keeperBot = keeper.right;
    keeperBot.offset += keeperBot.dir * keeperBot.speed;
    if (keeperBot.offset > goalWidth - keeperBot.width - 40) keeperBot.dir = -1;
    else if (keeperBot.offset < 0) keeperBot.dir = 1;
    keeperBot.x = W / 2 - goalWidth / 2 + 20 + keeperBot.offset;

    // Draw keeper images or placeholders
    if (keeperLeft.complete && keeperLeft.naturalWidth !== 0) {
      ctx.drawImage(keeperLeft, keeperTop.x, keeperTop.y, keeperTop.width, keeperTop.height);
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(keeperTop.x, keeperTop.y, keeperTop.width, keeperTop.height);
    }

    if (keeperRight.complete && keeperRight.naturalWidth !== 0) {
      ctx.drawImage(keeperRight, keeperBot.x, keeperBot.y, keeperBot.width, keeperBot.height);
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(keeperBot.x, keeperBot.y, keeperBot.width, keeperBot.height);
    }
  }

  // Reset ball to center and stop movement
  function resetBall() {
    W = canvas.width;
    H = canvas.height;
    ball.x = W / 2;
    ball.y = H / 2;
    ball.vx = 0;
    ball.vy = 0;
    ball.moving = false;
    updateKeepersPosition();
    // choose a new random correct goal on reset
    correctGoal = Math.random() < 0.5 ? 'top' : 'bottom';
    updateTargetCenter();
  }

  // Check if a goal scored and display messages
  let goalMessageTimeout = null;
  // Update target center based on current canvas size and which goal is correct
  function updateTargetCenter() {
    // Choose a random x within the goal frame (with small padding)
    const goalWidth = W * goalWidthRatio;
    const pad = 20; // keep marker away from goal edges
    const minX = W / 2 - goalWidth / 2 + pad;
    const maxX = W / 2 + goalWidth / 2 - pad;
    targetCenter.x = Math.random() * (maxX - minX) + minX;
    targetCenter.y = (correctGoal === 'top') ? (goalHeight / 2) : (H - goalHeight / 2);
  }
  function checkGoal() {
  const goalWidth = W * goalWidthRatio;

  // Top goal - right team goal
  if (ball.y - ball.r < goalHeight &&
      ball.x > W/2 - goalWidth/2 && ball.x < W/2 + goalWidth/2) {
    // Determine if this was the correct goal
    if (correctGoal === 'top') {
      displayMessage("🏆🏆🏆👑👑👑🏆🏆🏆", 'lime');
      // short delay so user sees message, then navigate
      setTimeout(() => { window.location.href = 'bike.html'; }, 900);
    } else {
      displayMessage("❌❌❌❌❌❌❌❌❌", 'red');
      setTimeout(() => { window.location.reload(); }, 1000);
    }
    return;
  }

  // Bottom goal - left team goal
  if (ball.y + ball.r > H - goalHeight &&
      ball.x > W/2 - goalWidth/2 && ball.x < W/2 + goalWidth/2) {
    // Determine if this was the correct goal
    if (correctGoal === 'bottom') {
      displayMessage("🏆🏆🏆👑👑👑🏆🏆🏆", 'lime');
      setTimeout(() => { window.location.href = 'bike.html'; }, 900);
    } else {
      displayMessage("❌❌❌❌❌❌❌❌❌", 'red');
      setTimeout(() => { window.location.reload(); }, 1000);
    }
    return;
  }

  // Wrong goal attempt if ball crosses top/bottom but outside goal area
  if (ball.y - ball.r < 0 || ball.y + ball.r > H) {
    displayMessage("❌ Wrong Goal Attempt!", 'red');
    resetBall();
  }
}


  // Check if keeper blocks the ball (simple AABB collision)
  function isKeeperBlocking(k) {
    return ball.x + ball.r > k.x &&
           ball.x - ball.r < k.x + k.width &&
           ball.y + ball.r > k.y &&
           ball.y - ball.r < k.y + k.height;
  }

  // Display temporary messages in info box
  function displayMessage(text, color = '#fff') {
    if (goalMessageTimeout) clearTimeout(goalMessageTimeout);
    info.textContent = text;
    info.style.color = color;
    goalMessageTimeout = setTimeout(() => {
      info.textContent = 'Swipe to kick the ball!';
      info.style.color = '#f0f0f0';
    }, 1500);
  }

  // Main game loop
  function gameLoop() {
    W = canvas.width;
    H = canvas.height;

    ctx.clearRect(0, 0, W, H);

  drawField();
    animateKeepers();
    drawBall();
    moveBall();
    checkGoal();

    requestAnimationFrame(gameLoop);
  }

  gameLoop();

  // Swipe handling logic
  function handleSwipeStart(x, y) {
    swipeStart = { x, y };
    lastTouch = Date.now();
  }

  function handleSwipeEnd(x, y) {
    swipeEnd = { x, y };
    if (swipeStart && !ball.moving && (Date.now() - lastTouch < 800)) {
      const dx = swipeEnd.x - swipeStart.x;
      const dy = swipeEnd.y - swipeStart.y;

      // Velocity limits for control
      ball.vx = Math.max(Math.min(dx / 12, 20), -20);
      ball.vy = Math.max(Math.min(dy / 12, 20), -20);
      ball.moving = true;
    }
    swipeStart = null;
  }

  // Mouse event listeners
  canvas.addEventListener('mousedown', e => {
    handleSwipeStart(e.offsetX, e.offsetY);
  });
  canvas.addEventListener('mouseup', e => {
    handleSwipeEnd(e.offsetX, e.offsetY);
  });

  // Touch event listeners
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const t = e.touches[0];
    handleSwipeStart(t.clientX - rect.left, t.clientY - rect.top);
  }, { passive: false });
  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const t = e.changedTouches[0];
    handleSwipeEnd(t.clientX - rect.left, t.clientY - rect.top);
  }, { passive: false });

  // Reset scores with 'r' key
  window.addEventListener('keydown', e => {
    if (e.key === 'r' || e.key === 'R') {
      // Scores are removed; just reset ball and show a message
      resetBall();
      info.textContent = 'Game reset. Swipe to kick the ball!';
      info.style.color = '#f0f0f0';
    }
  });
})();
</script>
</body>
</html>
